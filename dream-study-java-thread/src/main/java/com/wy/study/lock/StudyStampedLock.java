package com.wy.study.lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.StampedLock;/** * {@link StampedLock}:{@link ReadWriteLock}的增强版,ReadWriteLock是读写,写写互斥.StampedLock读读,读写时不互斥, * 若读的时候有写操作,写完之后再升级为读写锁.但是该锁不支持条件变量,也不支持重入 *  * <pre> * StampedLock是一个读写锁,因此也会像读写锁那样,把一个state变量分成两半,分别表示读锁和写锁的状态. * 同时,它还需要一个数据的version.但是,一次CAS没有办法操作两个变量,所以这个state变量本身同时也表示了数据的version. * 用最低的8位表示读和写的状态,其中第8位表示写锁的状态,最低的7位表示读锁的状态.因为写锁只有一个bit位,所以写锁是不可重入的 *  * {@link StampedLock#LG_READERS}: 7 * {@link StampedLock#RUNIT}: 1L; * {@link StampedLock#WBIT}: 1L << LG_READERS; 第8位表示写锁 * {@link StampedLock#RBITS}: WBIT - 1L; 最低的7位表示读锁 * {@link StampedLock#RFULL}: RBITS - 1L; 读锁的数目 * {@link StampedLock#ABITS}: RBITS | WBIT; 读锁和写锁状态合二为一 * {@link StampedLock#ORIGIN}: WBIT << 1; tate的初始值 * {@link StampedLock#state}:初始值不为0,而是把WBIT向左移动了一位,也就是上面的ORIGIN,由构造赋值. * ->为什么state的初始值不设为0,由tryOptimisticRead()和validate()可以看出,如果stamp==0时,validate()一直都返回false. * ->当tryOptimisticRead()里的state&WBIT != 0时,说明有线程持有写锁,该方法会永远返回0.这样,再调用validate(0)也会永远返回false. * ->这正是我们想要的逻辑:当有线程持有写锁时,validate()永远返回false,无论写线程是否释放了写锁. * ->因为无论是否释放了(state回到初始值)写锁,state值都不为0,所以validate(0)永远为false. * ->为什么validate()方法不直接比较stamp==state,而要比较state&SBITS=state&SBITS 呢?因为读锁和读锁是不互斥的 * ->所以,即使在乐观读的时候,state值被修改了,但如果它改的是第7位,validate()还是会返回true. * ->validate()使用了内存屏障sun.misc.Unsafe.loadFence()是为了防止下一行里面的stamp,SBITS指令重排 *  * {@link StampedLock#tryOptimisticRead}:乐观读锁,会返回一个版本号,如果获取读锁的同时有写锁,该版本号会被改变 * {@link StampedLock#validate()}:检查版本是否被修改过,没有修改就证明乐观读锁获取成功. * 		该方法中state已经是volatile,所以可以禁止重排序,但stamp并不是volatile的,在方法里面插入内存屏障以禁止重排序 *  * {@link StampedLock.WNode}:StampedLock进行悲观的读锁和写锁操作不是基于AQS实现的,而是内部重新实现了一个阻塞队列,即WNode. * ->刚开始的时候,whead=wtail=NULL,然后初始化,建一个空节点,whead和wtail都指向这个空节点,之后往里面加入一个个读线程或写线程节点. * ->但基于这个阻塞队列实现的锁的调度策略和AQS很不一样,也就是自旋. * ->在AQS里面,当一个线程CAS state失败之后,会立即加入阻塞队列,并且进入阻塞状态, * ->但在StampedLock中,CAS state失败之后,会不断自旋,自旋足够多的次数之后,如果还拿不到锁,才进入阻塞状态 * ->根据CPU的核数,定义了自旋次数的常量值:如果是单核的CPU,不能自旋;在多核情况下,才采用自旋策略 * {@link StampedLock.WNode#status}:队列状态,取值0,WAITING或CANCELLED * {@link StampedLock.WNode#mode}:队列模式,取值RMODE或WMODE * {@link StampedLock#writeLock()}:获取写锁 * {@link StampedLock#tryWriteLock()}:尝试获取写锁.当state&ABITS==0时,说明没有线程持有读锁或写锁, * 		此时当前线程才有资格通过CAS操作state.若操作不成功,则调用acquireWrite()方法进入阻塞队列,并进行自旋, * {@link StampedLock#acquireWrite()}:该方法是整个加锁操作的核心,方法内部是两个大的for循环,实现了非常复杂的自旋策略. * ->在第一个大的for循环里面,目的就是把该Node加入队列的尾部,一边加入,一边通过CAS操作尝试获得锁. * ->如果获得了,整个方法就会返回;如果不能获得锁,会一直自旋,直到加入队列尾部. * ->在第二个大的for循环里,也就是该Node已经在队列尾部了. * ->此时,如果发现自己刚好也在队列头部,说明队列中除了空的Head节点,就是当前线程了,再进行新一轮的自旋, * 		直到达到MAX_HEAD_SPINS次数,然后进入阻塞. * ->当release()被调用之后,会唤醒队列头部的第1个元素,此时会执行第二个大的for循环逻辑,也就是接着for循环里面park()后面的代码往下执行. * ->另外一个不同于AQS的阻塞队列的地方是,在每个WNode里面有一个cowait指针,用于串联起所有的读线程. * ->例如,队列尾部阻塞的是一个读线程 1,现在又来了读线程 2,3,那么会通过cowait指针,把1,2,3串联起来. * ->1被唤醒之后,2,3也随之一起被唤醒,因为读和读之间不互斥. * {@link StampedLock#unlockWrite()}:释放锁.和读写锁的实现类似,一是把state重置,二是唤醒阻塞队列中的第一个节点 * </pre> * * @author 飞花梦影 * @date 2021-06-05 10:05:42 * @git {@link https://gitee.com/dreamFlyingFlower} */public class StudyStampedLock {	private int balance;	private StampedLock lock = new StampedLock();	public void conditionReadWrite(int value) {		// 首先判断balance的值是否符合更新的条件		long stamp = lock.readLock();		while (balance > 0) {			// 读锁转写锁			long writeStamp = lock.tryConvertToWriteLock(stamp);			if (writeStamp != 0) {				// 成功转换成为写锁				stamp = writeStamp;				balance += value;				break;			} else {				// 没有转换成写锁,这里需要首先释放读锁,然后再拿到写锁				lock.unlockRead(stamp);				// 获取写锁				stamp = lock.writeLock();			}		}		try {		} finally {			lock.unlock(stamp);		}	}	public void optimisticRead() {		// 乐观读锁		long stamp = lock.tryOptimisticRead();		int c = balance;		try {			// 这里可能会出现了写操作,因此要进行判断.如果判断不通过,要重新读			if (!lock.validate(stamp)) {				// 要从新读取				long readStamp = lock.readLock();				c = balance;				stamp = readStamp;			}			System.out.println(c);		} finally {			lock.unlockRead(stamp);		}	}	public void write(int value) {		// 普通写锁		long stamp = lock.writeLock();		try {			balance += value;		} finally {			lock.unlockWrite(stamp);		}	}}
package com.wy.study.lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.StampedLock;/** * {@link StampedLock}:{@link ReadWriteLock}的增强版,ReadWriteLock是读写,写写互斥.StampedLock读读,读写时不互斥, * 若读的时候有写操作,写完之后再升级为读写锁.但是该锁不支持条件变量,也不支持重入 * * @author 飞花梦影 * @date 2021-06-05 10:05:42 * @git {@link https://gitee.com/dreamFlyingFlower} */public class StudyStampedLock {	private int balance;	private StampedLock lock = new StampedLock();	public void conditionReadWrite(int value) {		// 首先判断balance的值是否符合更新的条件		long stamp = lock.readLock();		while (balance > 0) {			// 读锁转写锁			long writeStamp = lock.tryConvertToWriteLock(stamp);			if (writeStamp != 0) {				// 成功转换成为写锁				stamp = writeStamp;				balance += value;				break;			} else {				// 没有转换成写锁,这里需要首先释放读锁,然后再拿到写锁				lock.unlockRead(stamp);				// 获取写锁				stamp = lock.writeLock();			}		}		try {		} finally {			lock.unlock(stamp);		}	}	public void optimisticRead() {		// 乐观读锁		long stamp = lock.tryOptimisticRead();		int c = balance;		try {			// 这里可能会出现了写操作,因此要进行判断.如果判断不通过,要重新读			if (!lock.validate(stamp)) {				// 要从新读取				long readStamp = lock.readLock();				c = balance;				stamp = readStamp;			}			System.out.println(c);		} finally {			lock.unlockRead(stamp);		}	}	public void write(int value) {		// 普通写锁		long stamp = lock.writeLock();		try {			balance += value;		} finally {			lock.unlockWrite(stamp);		}	}}
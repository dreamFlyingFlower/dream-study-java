package dream.study.common;

/**
 * 进制
 * 
 * 计算机中所有的数据都是二进制存储,即0和1.一个字节(byte)等于8位(bit),int是32位,最大值就是2的0次幂依次加到2的31次幂
 * 
 * <pre>
 * 原码:第一位为符号位,0为正数,1为负数;负数的二进制就是正数的二进制取反再加1
 * 反码:也叫取反,符号位不动,原码取反,0变成1,1变成0
 * 补码:负数补码符符号位不动,反码加1,正数补码即为原码.补码是为了解决正数和负数的运算问题存在的,
 * 因为二进制中存在+0和-0,他们的二进制表现形式不同,导致四则运算时,中间多了一个数
 * 		+0=00000000 00000000 00000000 00000000,-0=10000000 00000000 00000000 00000000
 *		+4  =	00000000	00000000	00000000	00000100
 *	+4取反=	01111111			11111111			11111111			11111011
 *
 * 		6   =	00000000	00000000	00000000	00000110
 *	+ -4	  = 11111111		 	11111111		 	11111111		 	11111011		不+1
 *------------------------------------------------------------------------------
 *				00000000	00000000	00000000	00000001		=1
 *
 * 		6   =	00000000	00000000	00000000	00000110
 * +	-4  =	11111111		 	11111111		 	11111111		 	11111100		+1
 * ------------------------------------------------------------------------------
 * 			 	00000000 	00000000	00000000	00000010		=2,-4不加1,则值等于1
 * </pre>
 * 
 * 二进制运算:&(与),|(或),^(异或),~(反码),<<(左移),>>(右移),>>>(无符号右移)
 * 
 * <pre>
 * &:一假为假,二进制位上有0就得到0.如:6&3=2
 * |:一真为真,二进制位上有1就得到1.如:6|3=7
 * ~:取反,如:~6=-7
 * ^:异或,当二进制位上相同时得0,不同得1;当一个数被同一个数异或2次得到的结果仍然是原来的数,用于加密.如:6^3=5,5^3=6
 * <<:左移,二进制位整体左移n位,即原有值乘以2的n次幂,如3<<2=3*2的平方=12.右边多出来的位置补0.注意,int左移可能会变成负数
 * >>:右移的最高位,原来是什么就用什么补位,如6>>2=1.和左移相同,只不过是除以2的n次幂,结果取整
 * >>>:无符号右移和右移的区别在于最高位的补位都是0,不会补1
 * </pre>
 * 
 * @author 飞花梦影
 * @date 2019-03-25 13:32:06
 */
public class S_Radix {

}